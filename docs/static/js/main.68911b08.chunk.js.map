{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","categories","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","console","log","useFetchGifs","GifExpertApp","cat","ReactDOM","render","document","getElementById"],"mappings":"mMAyCeA,EArCK,SAAC,GAAyB,IAAtBC,EAAqB,EAArBA,cAEpB,EAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KAoBA,OACI,sBAAMC,SAdW,SAACC,GAElBA,EAAEC,iBAEGJ,EAAWK,OAAOC,OAAS,IAE5BR,GAAe,SAAAS,GAAU,OAAKP,GAAL,mBAAoBO,OAC7CN,EAAc,MAOlB,SACI,uBACIO,KAAK,OACLC,MAAQT,EACRU,SAvBc,SAACP,GAEvBF,EAAcE,EAAEQ,OAAOF,a,+BCNlBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEbC,EAFa,iDAEmCC,UAAUH,GAF7C,+DAIAI,MAAOF,GAJP,cAIbG,EAJa,gBAKIA,EAAKC,OALT,uBAKXC,EALW,EAKXA,KAEFC,EAAOD,EAAKE,KAAK,SAACC,GAAS,IAAD,EAC5B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAXvB,kBAgBZM,GAhBY,4CAAH,sDCFPO,EAAc,SAAC,GAAuB,EAArBJ,GAAsB,IAAlBT,EAAiB,EAAjBA,IAAKU,EAAY,EAAZA,MAInC,OACI,sBAAKI,UAAU,0CAAf,UAEI,qBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,4BAAIA,QCJHO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAEvB,ECEyB,SAACA,GAEzB,MAA0Bd,mBAAS,CAC/BqB,KAAM,GACNa,SAAS,IAFb,mBAAOC,EAAP,KAAcC,EAAd,KAgCA,OAzBAC,qBAAW,WAGPxB,EAAQC,GACHwB,MAAM,SAAAC,GAICC,QAAQC,IAAIF,GAEZH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAO3B,CAACpB,IAMIqB,EDpCuBO,CAAa5B,GAAhCa,EAAZ,EAAON,KAAaa,EAApB,EAAoBA,QAEnB,OACI,qCACI,qBAAIJ,UAAU,oCAAd,cAAoDhB,EAApD,OAECoB,GAAW,mBAAGJ,UAAU,mCAAb,wBAEZ,qBAAKA,UAAU,YAAf,SAGQH,EAAOJ,KAAI,SAACC,GAAD,OACP,cAAC,EAAD,eAGSA,GAFAA,EAAIC,aEoBtBkB,EArCM,WAGjB,MAAoC3C,mBAAS,CAAC,YAAa,YAA3D,mBAAOQ,EAAP,KAAmBT,EAAnB,KAOA,OACI,qCACI,8CAGA,cAAC,EAAD,CAAaA,cAAeA,IAE5B,uBAKQS,EAAWe,KAAK,SAACqB,GAAD,OACZ,cAAC,EAAD,CAII9B,SAAY8B,GADNA,U,MCtBlCC,IAASC,OACL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.68911b08.chunk.js","sourcesContent":["import React, { useState } from 'react'\nimport PropTypes from 'prop-types';\n\n                       //Comunicacion entre componentes: Este componente AddCategory recibe una propiedad o prop enviada desde otro componente padre GifExpertApp\nconst AddCategory = ( { setCategories } ) => {\n    \n    const [inputValue, setInputValue] = useState('');//useState() si se hubiese colocado asi el estado inicial es undefined es da warning\n    \n    const handleInputChange = (e) => {\n        //console.log(e.target.value);\n        setInputValue(e.target.value);\n    }\n\n    const handleSubmit = (e) => {\n        \n        e.preventDefault();\n    \n        if ( inputValue.trim().length > 2 ) {\n            //setCategories es un metodo asociado a un estado que se encuentra en otro componente, que se recibio como prop en este componente \n            setCategories( categories => [inputValue, ...categories]);//Se puede usar de esa forma(recibiendo como argumento una funcion flecha que recibe como argumento el estado segun la definicion de useState de REACT) ya que en este componente solo recibimos como props el metodo que cambia el estado de categorias y no el estado como tal\n            setInputValue('');\n        }\n\n\n    }\n    \n    return (\n        <form onSubmit={ handleSubmit }>\n            <input \n                type='text'\n                value={ inputValue } \n                onChange={ handleInputChange } \n            />\n        </form>\n    )\n}\n\nAddCategory.propTypes = {\n    setCategories: PropTypes.func.isRequired,\n}\n\nexport default AddCategory;\n","//Los helpers son funciones que hacen un cierto trabajo en especifico, pueden recibir argumentos, lo procesan y hacen algun return. Se consideran helper aquellas funciones que no hacen falta que redibujen el state o algo asi  \n\n\n//UN HELPER, que hace peticiones a una API\nexport const getGifs = async( category ) => {\n\n    const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=MjrcR0hLAqOVz4aGIeN4ZpXXACCCsTqT`;//la funcion encodeURI hace reemplazo de espacios por porcentaje entre otras cosas\n\n    const resp = await fetch( url );\n    const { data } = await resp.json();\n\n    const gifs = data.map( (img) => {\n        return {\n            id: img.id,\n            title: img.title,\n            url: img.images?.downsized_medium.url\n        }\n    });\n\n\n    return gifs;//getGifs como es async ya no es una funcion que retorna los gifs sino es una funcion que retorna una promesa que resuelve la coleccion de los gifs\n\n}","import React from 'react'\n\nexport const GifGridItem = ({ id, url, title }) => {\n    \n   // console.log( id, url, title );\n    \n    return (\n        <div className='card animate__animated animate__bounce '>\n            \n            <img src={url} alt={title} />\n            <p>{title}</p>\n\n        </div>\n    )\n}\n","import React from 'react';\nimport { useFetchGifs } from '../hooks/useFetchGifs';\n\nimport { GifGridItem } from './GifGridItem';\n\n//UN COMPONENTE, que muestra la informacion en pantalla\nexport const GifGrid = ({ category }) => {\n    \n   const {data:images, loading} = useFetchGifs(category);\n\n    return (\n        <>\n            <h3 className='animate__animated animate__fadeIn'> {category} </h3>\n\n           { loading && <p className='animate__animated animate__flash'>Loading...</p> }\n\n            <div className='card-grid'>\n                \n                {\n                    images.map((img) => (\n                        <GifGridItem \n                            key={img.id}\n                            // img={img}\n                            { ...img }\n                        />\n                    ))\n                }\n        \n            </div> \n        </>\n    )\n}\n","//Custon hooks: es una forma de extraer logica de un componente o logica que se quiere reutilizar y extraerla de tal manera que sea sencillo de utilizar nuevamente.\n            //Se recomienda que los custom hooks se cree en una carpeta en /src llamada hooks. El nombre se recomienda que comience con use... lo que significa que es un hook\n            //Los hooks no son mas que funciones, por lo tanto los custom hooks tambien son funciones\n            //Los custom hooks tambien pueden tener su estado, es decir se puede usar dentro de su cuerpo otros hooks como el useState\n            //FUncionan como los functional components, pueden tener efectos, usar reducer, contextos, etc\n\nimport { useEffect, useState } from \"react\"\nimport { getGifs } from \"../helpers/getGifs\";\n\n//UN CUSTOM HOOK: que busca la informacion a mostrar a traves de una API(LA API LA GESTIONA UN HELPER)\nexport const useFetchGifs = (category) => {\n    \n    const [state, setState] = useState({\n        data: [],\n        loading: true\n    });\n\n    //useEffect permite ejecutar cierto codigo de forma condicional. Esto es util para cuando se haga un cambio en el componente y se tenga que renderizar de nuevo el componente y no queremos que algo se ejecute entonces usamos el useEffect para controlar esa ejecucion\n    //El useEffect no puede ser async porque espera algo sincrono, es decir NO SE PUEDE HACER useEffect( async() => {} )\n    useEffect( () => {\n\n        //getGifs retorna una promesa\n        getGifs(category)\n            .then( imgs => {\n\n                // setTimeout(() => {\n\n                    console.log(imgs)\n\n                    setState({\n                        data: imgs,\n                        loading: false\n                    });\n                // }, 3000);\n\n\n            })\n\n    },[category] );//El segundo parametro del useEffect es un arreglo de dependencias. \n                    //Sino se coloca este segundo parametro entonces el useEffect se ejecuta o dispara al inicio y cada vez que se renderiza el componente\n                    //Si se coloca el segundo argumento como arreglo vacio entonces el useEffect se dispara una sola vez al montarse el componente\n                    //Si se colocar el segundo argumento con un arreglo de dependencias entonces el useEffect se ejecuta cada vez que alguna de las dependencias cambie\n\n\n    return state;// { data:[], loading: true }\n\n}\n","import React, { useState } from 'react';\nimport AddCategory from './components/AddCategory';\nimport { GifGrid } from './components/GifGrid';\n\nconst GifExpertApp = () => {\n\n\n    const [categories, setCategories] = useState(['Samurai X', 'madonna']);\n\n    // const handleAdd = () => {\n    //     //setCategories(['Cuarto',...categories]); ...categories se extrae todo el contenido del arreglo categories\n    //     setCategories( categories => [...categories, 'HunterXHunter']);\n    // };\n\n    return (\n        <>\n            <h2>GifExpertApp</h2>\n\n            {/* Comunicacion entre componentes: se le puede enviar una propiedad de este componente padre al componente hijo AddCategory. Esta propiedad puede ser una variable, un metodo, un metodo que cambia un estado, etc */}\n            <AddCategory setCategories={setCategories} />\n\n            <hr />\n\n            {/* <ol> */}\n                {\n                    //Se recomienda usar map que es un metodo asociados a los arreglos para mostrar sus elementos en la vista del componente, ya que este metodo siempre retorna algo en cada iteracion, mientras que si se usa un for normal este no retorna nada, solo hace el recorrido\n                    categories.map( (cat) =>  (\n                        <GifGrid\n                            //Cuando se va a mostrar un listado o elementos de un arreglo se debe usar la propiedad key porque sino manda un warning. Los valores que deben ponerse en el key deben ser valores unicos, que por lo general se colocan los ids que vienen de la BD, No se deben colocar como valores las posiciones del array al momento de recorrer el arreglo, porque son volatiles, pueden cambiar\n                            //El key sirve para que react sepa cual es el elemento que esta iterando. Si se necesita hacer algo con el elemento asociado a ese key, react se basa en ese key para hacer los cambios correspondientes y asi react saber que elemento renderizar nuevamente\n                            key={ cat } \n                            category = {cat} \n                        />\n                    ))\n                }\n            {/* </ol> */}\n        </>\n    );\n\n}\n\nexport default GifExpertApp;\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport GifExpertApp from './GifExpertApp';\n\nimport './index.css';\n\n\nReactDOM.render(\n    <GifExpertApp />,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}